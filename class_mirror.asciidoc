=== Obtaining a class mirror

==== Problem

You want to do runtime introspection on a class, but don't know how to obtain
a mirror on that class.

==== Solution

To get a class mirror, you need an instance of the class, or the name of the
library where the class is defined.

If you have an instance, you can use the top level `reflectClass()` function
defined in the `dart:mirrors` library. This function returns a ClassMirror
object:

--------------------------------------------------------------------------------
var classMirror = reflectClass(myObj.runtimeType);
MirrorSystem.getName(classMirror.simpleName); // 'MyClass'
--------------------------------------------------------------------------------

If you have an InstanceMirror, use the InstanceMirror's `type` property to get
the ClassMirror:

--------------------------------------------------------------------------------
var myObj = new MyClass();
var instanceMirror = reflect(myObj);
var classMirror = instanceMirror.type;
MirrorSystem.getName(classMirror.simpleName); // 'MyClass'
--------------------------------------------------------------------------------

If you know the name of the library where the class is defined, you can obtain
a mirror on that library, and then use the library mirror's `classes` property
to obtain a ClassMirror.  A LibraryMirror's `classes` property returns a map,
where the map keys are the class names (expressed as Symbols), and the map
values are the associated ClassMirror objects.

Here is how you can get a ClassMirror on the StringBuffer class defined in the
'dart:core' library:

--------------------------------------------------------------------------------
var mirrorSystem = currentMirrorSystem();
var libraryMirror = mirrorSystem.findLibrary(const Symbol('dart.core')).first;
var classMirror = libraryMirror.classes[const Symbol('StringBuffer')];
MirrorSystem.getName(classMirror.simpleName); // 'StringBuffer'
--------------------------------------------------------------------------------

=== Querying the inhertance hierarchy of a class

==== Problem

You want to obtain information about the inheritance hierarchy of a class at
runtime. You want to find the superclass of a class, and you want to determine
whether a class is found in the inheritance hierarchy of another class.

==== Solution

For the examples below, assume the following class definitions:

--------------------------------------------------------------------------------
class A {}
class B extends A {}
class C extends B {}
--------------------------------------------------------------------------------

To find the superclass of a class, first obtain a mirror on the class:

--------------------------------------------------------------------------------
var classMirror = reflect(new C()).type;
--------------------------------------------------------------------------------

Then, use the mirror's `superclass` property to get the superclass:

--------------------------------------------------------------------------------
var classMirror = reflect(new C()).type;
MirrorSystem.getName(classMirror.superclass.simpleName); 'B'
--------------------------------------------------------------------------------

Using `superclass` returns a new ClassMirror object. This means that you can
use `superclass` to move higher in the inheritance hierarchy:

--------------------------------------------------------------------------------
classMirror = classMirror.superclass;
MirrorSystem.getName(classMirror.superclass.simpleName); 'A'
--------------------------------------------------------------------------------

All Dart objects have the Object class as the highest class in the inheritance
hierarchy. Because we never explicitly defined a superclass for A, A's
superclass is Object:

--------------------------------------------------------------------------------
classMirror = classMirror.superclass;
MirrorSystem.getName(classMirror.superclass.simpleName); 'Object'
--------------------------------------------------------------------------------

The superclass of Object is also Object:

--------------------------------------------------------------------------------
classMirror = reflect(new Object()).type;
MirrorSystem.getName(classMirror.superclass.simpleName); // 'Object'
--------------------------------------------------------------------------------

Using the `superclass` property, it is quite easy to get the entire inheritance
hierarchy of a class:

-------------------------------------------------------------------------------
import 'dart:mirrors';

Iterable classHierarchy(object) {
  List<Symbol> ancestorClasses = [];
  ClassMirror classMirror = reflect(object).type;
  while (classMirror.simpleName != const Symbol('Object')) {
    classMirror = classMirror.superclass;
    ancestorClasses.add(classMirror.simpleName);
  }
  return ancestorClasses;
}

void main() {
  List<String> hierarchy = classHierarchy(new C()).map((symbol) {
    return MirrorSystem.getName(symbol)
  }).toList();

  print(hierarchy); // ['B', 'A', 'Object']
}
--------------------------------------------------------------------------------

You can use the `classHierarchy()` function defined above to find out if a
class lies in the inheritance hierarchy of another class:

--------------------------------------------------------------------------------
void main() {
  List<String> hierarchy = classHierarchy(new B()).map((symbol) {
    return MirrorSystem.getName(symbol)
  }).toList();

  print(hierarchy); // ['C', 'Object']
  print(hierarchy.indexOf(new A().runtimeType.toString())); //  1
  print(hierarchy.indexOf(new C().runtimeType.toString())); // -1
}
--------------------------------------------------------------------------------

The String `indexOf` method used above returns -1 if a match is not found.
Otherwise, it returns the index at which the match is found. The code above
shows that A is found in the inheritance hierarchy of B, but C is not.

=== Dynamically creating a new class instance

==== Problem

You have a mirror on a class and want to create a new instance using that
mirror.

==== Solution

Assume the following Point class:

--------------------------------------------------------------------------------
class Point {
  num x, y;
  Point(this.x, this.y);
  Point.fromJson(String json) {
    // ...
  }
}
--------------------------------------------------------------------------------

You can obtain a mirror on the Point class through a point instance, and you can
create a new Point instance using the ClassMirror's `newInstance()` method. This
method invokes constructor passed to it as an argument, and returns a mirror on
the result.

--------------------------------------------------------------------------------
var point = new Point(1, 2);
var classMirror = reflect(point).type;
var point2 = classMirror.newInstance(new Symbol(''), [3, 4]).reflectee;
expect(point2.x, equals(3));
expect(point2.y, equals(4));
--------------------------------------------------------------------------------

Passing a Symbol created from an empty string to `newInstance()` invokes the
generative Point constructor.

To invoke a named constructor, pass the constructor's name to `newInstance()`:

--------------------------------------------------------------------------------
var point2 = classMirror.newInstance(new Symbol('fromJson'),
  ['{"x":3,"y":4}']).reflectee;
point2.x; // 3
point2.y; // 4
--------------------------------------------------------------------------------

You can also invoke the `newInstanceAsync()` method. The syntax for
`newInstanceAsync()` is the same as `newInstance()`, but `newInstanceAsync()`
works asynchronously and returns the mirror on the newly created  instance via a
Future:

--------------------------------------------------------------------------------
var point2;
classMirror.newInstanceAsync(new Symbol('fromJson'), ['{"x":3,"y":4}'])
  .then((mirror) {
    point2 = mirror.reflectee;
  });
--------------------------------------------------------------------------------


