== Mirrors and reflection

Mirrors in Dart are objects that reflect other objects.  If you want to reflect
on an object in Dart, you must first obtain a mirror on that object, and then
use the mirror to obtain information about the reflectee.

Mirrors are defined in 'dart:mirrors' library. All examples in this chapter
assume that you will import this library. Here's how you can do that:

--------------------------------------------------------------------------------
import 'dart:mirror';
--------------------------------------------------------------------------------

The recipes in this chapter address common use cases for Mirrors. The Mirrors
API provides several types of mirrors to reflect on different Dart objects. For
example, ClassMirrors reflect on classes, LibraryMirrors on libraries, and
InstanceMirrors on class instances. Look at the API docs to get a complete list
of the types of Mirrors provided in the `dart:mirrors` library.

Here are some things you should read before you dive into the recipes. Knowledge
of this material is assumed in the recipes.


===== Obtaining an instance mirror

To obtain information about a class instance, you need an InstanceMirror.  To
obtain an InstanceMirror, use the top level `reflect()` function defined in the
'dart:mirrors' library:

--------------------------------------------------------------------------------
MyClass myObj = new MyClass();
InstanceMirror myObjMirror = reflect(myObj);
--------------------------------------------------------------------------------

You can get a reference to the object being reflected by using the
InstanceMirror's `reflectee` property:

--------------------------------------------------------------------------------
myObjMirror.reflectee; // myObj
--------------------------------------------------------------------------------

===== Obtaining a library mirror

The Mirror API allows you to reflect on the libraries associated with your
program. To obtain information about a Dart library, you need a LibraryMirror.
To obtain a LibraryMirror, first use the top level `currentMirrorSystem()`
function to get the MirrorSystem associated with the current isolate:

--------------------------------------------------------------------------------
final MirrorSystem mirrorSystem = currentMirrorSystem();
--------------------------------------------------------------------------------

Then, use the MirrorSystem's `findLibrary()` method to get the mirror for a
specific library. The `findLibrary()` method returns an iterable of all
matching libraries in the mirror system:

--------------------------------------------------------------------------------
var libraryMirror = mirrorSystem.findLibrary(const Symbol('dart.core')).first;
print(MirrorSystem.getName(libraryMirror.simpleName)); // 'dart.core'
--------------------------------------------------------------------------------

Note that to obtain a mirror for the 'dart:core' library, you must pass a symbol
constructed using the 'dart.core' string (use a '.' instead of a ':').

===== Obtaining a class mirror from an instance or an InstanceMirror

To obtain information about a class, you need a ClassMirror. To obtain a
ClassMirror, you first need an instance of the class, or the name of the
library where the class is defined.

If you have an instance, you can use the top level `reflectClass()` function
defined in the `dart:mirrors` library. This function returns a ClassMirror
object:

--------------------------------------------------------------------------------
var classMirror = reflectClass(myObj.runtimeType);
MirrorSystem.getName(classMirror.simpleName); // 'MyClass'
--------------------------------------------------------------------------------

If you have an InstanceMirror, use the InstanceMirror's `type` property to get
the ClassMirror:

--------------------------------------------------------------------------------
var myObj = new MyClass();
var instanceMirror = reflect(myObj);
var classMirror = instanceMirror.type;
MirrorSystem.getName(classMirror.simpleName); // 'MyClass'
--------------------------------------------------------------------------------

===== Obtaining a class mirror from a library mirror

If you know the name of the library where the class is defined, you can obtain
a mirror on that library, and then use the library mirror's `classes` property
to obtain a ClassMirror.  The `classes` property returns a map, where the keys
are the class names (expressed as Symbols), and the values are the associated
ClassMirror objects.

Here, for example, is how you can get a ClassMirror on the StringBuffer class
defined in the 'dart:core' library:

--------------------------------------------------------------------------------
var mirrorSystem = currentMirrorSystem();
var libraryMirror = mirrorSystem.findLibrary(const Symbol('dart.core')).first;
var classMirror = libraryMirror.classes[const Symbol('StringBuffer')];
MirrorSystem.getName(classMirror.simpleName); // 'StringBuffer'
--------------------------------------------------------------------------------

===== Converting a string into a symbol

Working with mirrors in Dart frequently involves using maps where the
keys are object names and the values are the associated mirrors.  The Mirrors
API requires you to use Symbols to represent object names. To convert a string
to a Symbol, use the Symbol constructor:

--------------------------------------------------------------------------------
var myObjectAsSymbol = const Symbol('myObject');
--------------------------------------------------------------------------------

Calling the Symbol constructor with const rather than new allows dart2js to
minify all identifiers in the program. This helps keep the generated JavaScript
small.

===== Converting a symbol into a string

To convert a Symbol to a string, use the static `getName()` method provided by
the MirrorSystem class.

--------------------------------------------------------------------------------
var myObjAsString = MirrorSystem.getName(myObjectAsSymbol);
--------------------------------------------------------------------------------

===== Getting the name of the reflected object

Use a mirror's `simpleName` property to get its name, and use its
`qualifiedName` property to get its fully qualified name. The latter returns
the name of an entity prefixed by the name of that entity's owner.

The following examples show the usage of `simpleName` and `qualifiedName`:

--------------------------------------------------------------------------------
LibraryMirror libraryMirror = currentMirrorSystem().findLibrary(
    const Symbol('dart.json')).first;
print(libraryMirror.simpleName);    // Symbol('dart.json')
print(libraryMirror.qualifiedName); // Symbol('dart.json')

// The dart:json library defines a JsonParser class.
ClassMirror classMirror = libraryMirror.classes[const Symbol('JsonParser')];
print(classMirror.simpleName);   // Symbol('JsonParser')
print(classMirror.qualifiedName; // Symbol('dart.json.JsonParser')

// The JsonParser class contains a parseNumber method.
MethodMirror methodMirror = classMirror.members[const Symbol('parseNumber')];
print(methodMirror.simpleName);    // Symbol('parseNumber')
print(methodMirror.qualifiedName); // Symbol('dart.json.JsonParser.parseNumber')
--------------------------------------------------------------------------------


=== Checking if a class implements a particular constructor

==== Problem

You have the name of a constructor as a string, and you want to know if a
class implements that constructor.

==== Solution

For this recipes, assume you've defined a class that implements both a
generative and a named constructor:

--------------------------------------------------------------------------------
class Point {
  num x, y;
  Point(...) {...}
  Point.fromJson(...) {...}
}
--------------------------------------------------------------------------------

To reflectively check if a class implements a constructor, first obtain a
mirror on the class:

--------------------------------------------------------------------------------
Point point = new Point(3, 4);
ClassMirror classMirror = reflect(point).type;
--------------------------------------------------------------------------------

Then, use the mirror's `constructors` property to obtain a constructors map
for the class. The keys of this map are constructor names expressed as
Symbols, and the values of the map are mirrors on the associated constructors.

You can search for a key in this constructors map to see if the
class implements a constructor:

Searching this map for a constructor implemented by the class returns a mirror
on that constructor:

--------------------------------------------------------------------------------
classMirror.constructors[const Symbol('Point.fromJson')]; // Returns mirror.
classMirror.constructors[const Symbol('Point')];          // Returns mirror.
--------------------------------------------------------------------------------

Searching for an unsupported constructor returns `null`:

--------------------------------------------------------------------------------
classMirror.constructors[const Symbol('Point.XML')];     // null
--------------------------------------------------------------------------------

Note that you must prefix the name of the class to the name of the constructor
when checking if a constructor is supported by the class. But sometimes, the
name of the class is not available to you beforehand.  This could happen, for
example, if you are iterating over several classes and reflectively determining
which of those classes support a specific constructor and which do not.

When the name of the class is not available, use the ClassMirror's
`simpleName` getter to obtain the name:

--------------------------------------------------------------------------------
String className = MirrorSystem.getName(classMirror.simpleName);
classMirror.constructors[new Symbol('${className}.fromJson')];
--------------------------------------------------------------------------------


=== Instantiating a class from a string

==== Problem

You have the name of a class available as a string, and you want to reflectively
create a new instance of the class.

==== Solution

In the previous recipe we sketched out a skeletal Point class. We will use
that class once again in this recipe.

To reflectively instantiate a class, first obtain a mirror on the class. Then,
invoke the mirror's `newInstance()` method, passing it the constructor name, a
list of positional arguments, and (optionally) a map of named arguments:

--------------------------------------------------------------------------------
var point = new Point(1, 2);
var classMirror = reflect(point).type;
var point2 = classMirror.newInstance(new Symbol(''), [3, 4]).reflectee;
point2.x; // 3
point2.y; // 4
--------------------------------------------------------------------------------

Passing a Symbol created from an empty string to `newInstance()` invokes the
generative Point constructor (the constructor with the same name as the class).

To invoke a named constructor, pass the constructor's name to `newInstance()`:

--------------------------------------------------------------------------------
var point2 = classMirror.newInstance(new Symbol('fromJson'),
  ['{"x":3,"y":4}']).reflectee;
point2.x; // 3
point2.y; // 4
--------------------------------------------------------------------------------

You can also invoke the `newInstanceAsync()` method to create the new instance
asynchronously. The `newInstanceAsync()` method returns the mirror on the newly
created instance via a Future:

--------------------------------------------------------------------------------
var point2;
classMirror.newInstanceAsync(new Symbol('fromJson'), ['{"x":3,"y":4}'])
  .then((mirror) {
    point2 = mirror.reflectee;
  });
--------------------------------------------------------------------------------


=== Reflectively getting or setting the value of an object's fields

==== Problem

You have the name of an object's field as a string and you want to reflectively
get or set the value of that field.

==== Solution

Get an mirror on the instance, and use `getField()` to invoke a getter, and
`setField()` to invoke a setter. These methods work with implicit getters and
setters that access an object's fields, and they also work with getters and
setters defined using the `get` and `set` keywords.

Both `getField()` and `setField()` return mirrors.

Asynchronous versions of these methods, `getFieldAsync()` and `setFieldAsync()`
return their mirrors wrapped in a Future.

You can use the the returned mirror's `reflectee` property to get the reflected
value. The examples below show the use of these methods.

For this recipe, assume that you have defined the following class:

--------------------------------------------------------------------------------
class Rectangle {
  num left;
  num top;
  num width;
  num height;

  Rectangle(this.left, this.top, this.width, this.height);

  num get right             => left + width;
      set right(num value)  => left = value - width;
  num get bottom            => top + height;
      set bottom(num value) => top = value - height;
}
--------------------------------------------------------------------------------

Also assume that you have created a Rectangle instance, and you have obtained
a mirror on that instance:

--------------------------------------------------------------------------------
Rectangle rectangle = new Rectangle(3, 4, 20, 30);
InstanceMirror instanceMirror = reflect(rectangle);
--------------------------------------------------------------------------------

Here is how you can use `getField()` and `setField()` to invoke an object's
getters and setters:

--------------------------------------------------------------------------------
// Implicit getter.
instanceMirror.getField(new Symbol('left')).reflectee;    // 3

// Implicit setter.
instanceMirror.setField(new Symbol('left'), 10);
instanceMirror.getField(new Symbol('left')).reflectee;    // 10

// User defined getter.
instanceMirror.getField(const Symbol('right')).reflectee; // 23

// User defined setter.
instanceMirror.setField(const Symbol('right'), 21);
instanceMirror.getField(const Symbol('right')).reflectee; // 21
--------------------------------------------------------------------------------

And here is how you can invoke getters and setters asynchronously using
mirrors:

--------------------------------------------------------------------------------
instanceMirror.getFieldAsync(const Symbol('left'))
  .then((mirror) => print(mirror.reflectee));           // 3

instanceMirror.getFieldAsync(const Symbol('right'))
  .then((mirror) => print(mirror.reflectee));           // 23

instanceMirror.setFieldAsync(const Symbol('left'), 10)
  .then((_) => print(rectangle.left));                  // 10

instanceMirror.setFieldAsync(const Symbol('right'), 21)
  .then((_) => rectangle.right;                         // 21
--------------------------------------------------------------------------------


=== Invoking an instance method given its name as a string

==== Problem

You have the name of an instance method as a string and you want to invoke it
reflectively.


==== Solution

First obtain a mirror on the instance:

--------------------------------------------------------------------------------
var myObject = new MyClass();
var instanceMirror = reflect(myObject);
var data = instanceMirror.invoke(const Symbol('someMethod'), []).reflectee;
--------------------------------------------------------------------------------

Then, call the  `invoke()` method on the mirror, passing it the instance
method's name, a list of positional arguments, and (optionally) a map of named
arguments:

--------------------------------------------------------------------------------
var myObject = new MyClass();
var instanceMirror = reflect(myObject);
var data = instanceMirror.invoke(const Symbol('someMethod'), []).reflectee;
--------------------------------------------------------------------------------

The async equivalent of `invoke()` is `invokeAsync()`. Calling `invoke()`
returns a mirror on the result, and calling `invokeAsync()` returns the mirror
wrapped in a Future.

=== Checking if an object supports a method

==== Problem

You have a string representing a method, and you want to invoke the method on
an object. But you want to avoid triggering a NoSuchMethodError and want to
first know if the object supports that method.

==== Solution

To determine if an object supports a method, you need to determine if that
method is defined in the object's class, or an ancestor of that class.

For this recipe, assume you have defined the following class:

--------------------------------------------------------------------------------
class Person {
  String firstName, lastName;
  Person(...) {...}
  static List<Person> personsNamedBob() => ...;
  bool canVote() => ...;
}
--------------------------------------------------------------------------------

To determine if a method is defined in a class, first obtain a ClassMirror on
that class:

--------------------------------------------------------------------------------
Person person = new Person(...);
ClassMirror classMirror = reflect(person).type;
--------------------------------------------------------------------------------

Then, use the ClassMirror's `methods` property to get a method-name to
method-mirror map for the class.

Searching the `methods` map for a method implemented by the class returns a
mirror on that method:

--------------------------------------------------------------------------------
classMirror.methods[const Symbol('canVote')];       // Returns mirror.
--------------------------------------------------------------------------------

Searching the map for a method not implemented by the class returns `null`:

--------------------------------------------------------------------------------
classMirror.methods[const Symbol('somethingBogus')]; // null
--------------------------------------------------------------------------------

The `methods` map includes static methods:

--------------------------------------------------------------------------------
classMirror.members[const Symbol('personsNamedBob')]; // Returns mirror.
--------------------------------------------------------------------------------

You can use a mirror's `isStatic` property to determine if a member is static.

If a method is defined in a class and it isn't a static method, you can invoke
that method on a class instance without automatically triggering a
NoSuchMethodError.

If the method isn't defined in the class, you should query the inheritance
hierarchy of the class to see if an ancestor class defines the method. The
`methods` map only contains methods that are explicitly defined in the reflected
class. It does not include inherited methods:

--------------------------------------------------------------------------------
// We did not define a toString() in our Person class.
classMirror.members[const Symbol('toString')]; // null
--------------------------------------------------------------------------------

You can use the `hasMethod()` function defined below to determine if a method
is implemented in a class or any of its ancestor classes. This function takes
two arguments, a class instance and a method name. It reflects
first on the instance class, and if it does not find the method in the class
mirror's `methods` map, it queries the class's inheritance hierarchy, stopping
when it reaches Object:

--------------------------------------------------------------------------------
bool hasMethod(obj, symbol) {
  ClassMirror classMirror = reflect(obj).type;

bool _hasMethod(classMirror, symbol) {
  Mirror memberMirror = classMirror.members[symbol];
  // Make sure method is found and it is not a static method.
  if (memberMirror != null && !memberMirror.isStatic) {
    return true;
  } else  {
    if (MirrorSystem.getName(classMirror.simpleName) == 'Object') {
      return false;
    }
  }
  return _hasMethod(classMirror.superclass, symbol);
}
--------------------------------------------------------------------------------

The Person class implicitly inherits from the Object class, and `hasMethod()`
returns true for members inherited from Object:

--------------------------------------------------------------------------------
expect(hasMethod(classMirror, const Symbol('toString')), isTrue);
--------------------------------------------------------------------------------


=== Reflectively using static members of a class

==== Problem

You want to reflectively invoke static class methods, getters and setters.

==== Solution

--------------------------------------------------------------------------------
class SomeClass {
  static int someNum = 42;
  static int staticMethod() => ...;
  static int get staticGetter => ...;
  static void set staticSetter(int value) {
    ...
  }
}
--------------------------------------------------------------------------------

To invoke static class members, obtain a ClassMirror for the class and invoke
methods on it. Use the `getField()` method to invoke a getter and obtain a
mirror on the result.  The getter can be the implicit getter for a class
field, or it can be a user defined getter method:

--------------------------------------------------------------------------------
classMirror.getField(const Symbol('someNum')).reflectee; // 42
classMirror.getField(const Symbol('staticGetter')).reflectee;
--------------------------------------------------------------------------------

To set the value of a field, or to invoke a user defined setter, use
ClassMirror's `setField()` method:

--------------------------------------------------------------------------------
classMirror.setField(const Symbol('staticSetter'), 20);
classMirror.getField(const Symbol('staticGetter')).reflectee; // 20
--------------------------------------------------------------------------------

To invoke a static method and obtain a mirror on the result, use the
ClassMirror's `invoke()` method:

--------------------------------------------------------------------------------
classMirror.invoke(const Symbol('staticMethod'),[]).reflectee;
--------------------------------------------------------------------------------

You can also access static variables asynchronously. Use the
`getFieldAsync()`, `setFieldAsync()`, and `invokeAsync()` methods.

The ClassMirror API defines several properties to reflect on the contents of a
class. The `methods`, `getters`, and `setters` properties return method-name
to MethodMirror object maps. The `variables` property returns a variable-name
to VariableMirror map. The `members` property returns a member-name to mirror
map for for all class members.  This includes static methods, fields, getters,
and setters.

See the ClassMirror API docs for more details.


=== Getting the inhertance hierarchy of a class

==== Problem

You want to reflectively obtain information about the inheritance hierarchy of a
class. Perhaps you want to find the superclass of a class, or maybe you want to
determine whether a class is an ancestor of another class.

==== Solution

For the examples below, assume the following class definitions:

--------------------------------------------------------------------------------
class A {}
class B extends A {}
class C extends B {}
--------------------------------------------------------------------------------

To find the superclass of a class, obtain a mirror on the class, and then use
the mirror's `superclass` property to get the superclass:

--------------------------------------------------------------------------------
var classMirror = reflect(new C()).type;
var classMirror = reflect(new C()).type;
MirrorSystem.getName(classMirror.superclass.simpleName); 'B'
--------------------------------------------------------------------------------

Using `superclass` returns a new ClassMirror object. This means that you can
use `superclass` to traverse higher in the inheritance hierarchy:

--------------------------------------------------------------------------------
classMirror = classMirror.superclass;
MirrorSystem.getName(classMirror.superclass.simpleName); 'A'
--------------------------------------------------------------------------------

All Dart objects have the Object class as the highest class in the inheritance
hierarchy. Because we never explicitly defined a superclass for `A`, `A`'s
superclass is Object:

--------------------------------------------------------------------------------
classMirror = classMirror.superclass;
MirrorSystem.getName(classMirror.superclass.simpleName); 'Object'
--------------------------------------------------------------------------------

The superclass of Object is also Object:

--------------------------------------------------------------------------------
classMirror = reflect(new Object()).type;
MirrorSystem.getName(classMirror.superclass.simpleName); // 'Object'
--------------------------------------------------------------------------------

You can use the `superclass` property to get the full inheritance chain
associated with an object:

--------------------------------------------------------------------------------
Iterable classHierarchy(object) {
  List<Symbol> ancestorClasses = [];
  ClassMirror classMirror = reflect(object).type;
  while (classMirror.simpleName != const Symbol('Object')) {
    classMirror = classMirror.superclass;
    ancestorClasses.add(classMirror.simpleName);
  }
  return ancestorClasses;
}
--------------------------------------------------------------------------------


=== Finding the interfaces implemented by a class

==== Problem

You want to get a list of the interfaces implemented by a class.

==== Solution

Get a class mirror and use the `superinterfaces` property. This returns a list
of mirrors on the interfaces implemented by the class.

--------------------------------------------------------------------------------
ClassMirror classMirror = reflect(new ExampleClass()).type;
List<ClassMirror> interfaces = classMirror.superinterfaces;
--------------------------------------------------------------------------------

The `superinterfaces` property examines only the interfaces explicitly
implemented by the class being reflected on. It does not return interfaces
implemented by an ancestor of the class.

Assume you have defined the following classes:

--------------------------------------------------------------------------------
class ExampleClass implements Comparable {
  int compareTo(ExampleClass obj) {}
}

class ChildExampleClass extends ExampleClass {}
--------------------------------------------------------------------------------

Using the `superinterfaces` property, you can see that the parent class
implements `Comprarable`, but the child class does not:

--------------------------------------------------------------------------------
ClassMirror classMirror = reflect(new ExampleClass()).type;
classMirror.superinterfaces.map((interface) {
  return MirrorSystem.getName(interface.simpleName);
}).toList(); // ['Comparable']

classMirror = reflect(new ChildExampleClass()).type;
classMirror.superinterfaces.map((interface) {
  return MirrorSystem.getName(interface.simpleName);
}).toList(); // []
--------------------------------------------------------------------------------


=== Finging the number of parameters taken by a function or method

==== Problem

You want to know the number of parameters taken by a function or method.

==== Solution

Get a MethodMirror on the function or method, and use its `parameters`
property to get information about the expected parameters. Despite the name, a
MethodMirror allows you to reflect on both functions and methods.

Assume that you have defined the following class:

--------------------------------------------------------------------------------
class Student {
  bool hasRegistered() => false;
  bool enrolledIn(String classId) => false;
}
--------------------------------------------------------------------------------

You can reflectively confirm that the `hasRegistered()` is defined with no
parameters:

--------------------------------------------------------------------------------
Student student = new Student('8dj3kd12L');
ClassMirror classMirror = reflect(student).type;

MethodMirror methodMirror = classMirror.methods[const Symbol('hasRegistered')];
methodMirror.parameters.length; // 0
--------------------------------------------------------------------------------

And the `enrolledIn()` method is defined with a single parameter:

--------------------------------------------------------------------------------
methodMirror = classMirror.methods[const Symbol('enrolledIn')];
methodMirror.parameters.length; // 1
--------------------------------------------------------------------------------


=== Finding out which libraries are loaded in the current isolate

==== Problem

You want to use to reflection to find out which libraries have been loaded in
the current isolate.

==== Solution

First, use the top level `currentMirrorSystem()` function to get the
MirrorSystem associated with the current isolate:

--------------------------------------------------------------------------------
final MirrorSystem mirrorSystem = currentMirrorSystem();
--------------------------------------------------------------------------------

Then use the MirrorSystem's `libraries` property to get information about the
libraries in the mirror system.  The `libraries` property returns a map where
the keys are URI's representing library names, and the values are the
associated LibraryMirror objects:

--------------------------------------------------------------------------------
Map<Uri, LibraryMirror> libraries = mirrorSystem.libraries;
--------------------------------------------------------------------------------

Note that the map keys are URIs, not Symbols. This is because library names are
not necessarily unique within a MirrorSystem, and using URIs as keys handles
cases involving duplicate library names.

You can get the Symbol representing the name of a library in the map by using
the `simpleName` property of a map value:

--------------------------------------------------------------------------------
mirrorSystem.libraries.forEach((Uri libraryUri, LibraryMirror library) {
  Symbol libraryName = library.simpleName;
  ...
});
--------------------------------------------------------------------------------


=== Calling a top level library function

==== Problem

You want to reflectively invoke a top level function defined in a library.

==== Solution

Get a mirror on the library where the function is defined. Call the mirror's
`invoke()` method, passing the name of the function you want to invoke, a list
of positional arguments, and (optionally) a map of named arguments. Calling
`invoke()` returns a mirror on the value returned by the invoked function:

--------------------------------------------------------------------------------
var jsonPerson = '{"name" : "joe", "date" : [2013, 3, 10]}';
person = libraryMirror.invoke(const Symbol('parse'), [jsonPerson]).reflectee;
person['name']; // 'joe'
--------------------------------------------------------------------------------


