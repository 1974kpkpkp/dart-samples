== Dart basics (????)

[[3.08]]

=== Defining a constructor with default parameters

Problem

You want to know the syntax for providing default positional and named
arguments to a constructor.

You want to know how to define a constructor with positional or named parameters
with default values.

Solution

In the constructor signature, wrap default positional arguments in a `[]`, and
wrap default named arguments in a `{}`:

Here is an example of a class with a constructor that takes positional
parameters with default values:

--------------------------------------------------------------------------------
class Point {
  num x, y;
  Point([this.x = 0, this.y = 0]);
}
--------------------------------------------------------------------------------

You can now call the constructor with zero, one, or two arguments;

--------------------------------------------------------------------------------
Point point = new Point();
point.x; // 0
point.y; // 0

point = new Point(3);
point.x; // 3
point.y; // 0

point = new Point(3, 4);
point.x; // 3
point.y; // 4
--------------------------------------------------------------------------------

Here is an example of a class with a constructor that takes named parameters
with default values:

--------------------------------------------------------------------------------
class Point {
  num x, y;
  Point({this.x: 0, this.y: 0});
}
--------------------------------------------------------------------------------

You can use `key:value` notation to pass in arguments to the constructor:

--------------------------------------------------------------------------------
Point point = new Point();
point.x; // 0
point.y; // 0

point = new Point(x : 3);
point.x; // 3
point.y; // 0

point = new Point(x : 3, y : 4);
point.x; // 3
point.y; // 4
--------------------------------------------------------------------------------


=== Implementing named constructors

Problem

// You want you class to be instantiable using a variety of parameters. You want

// Therefore the only way to differentiate between the various constructors of a
// class is by the parameter list. But if there are lots of constructors, the
// differences between them become somewhat subtle and error prone.

http://en.wikibooks.org/wiki/More_C%2B%2B_Idioms/Named_Constructor

Solution

Use named constructors

--------------------------------------------------------------------------------
class Point {
  num x, y;

  Point(this.x, this.y);

  Point.zero(){
    x = 0;
    y = 0;
  }
}
--------------------------------------------------------------------------------


=== Implementing caching using a factory constructor

=== Invoking a superclass constructor

--------------------------------------------------------------------------------
class Employee extends Person {
  String employeeID;

  Employee(name, employeeID) : super(name) {
    this.employeeID = employeeID;
  }
  String toString() => '$name, $employeeID';
}
--------------------------------------------------------------------------------

--------------------------------------------------------------------------------
class Item {
  String name;
  Item();
  Item.named(this.name);
}

class Widget extends Item {
  String sku;
  Widget(name, this.sku) : super.named(name);
}
--------------------------------------------------------------------------------

=== Assigning value to final fields

--------------------------------------------------------------------------------
class Book {
  final String ISBN;
  Book(String ISBN) : ISBN = ISBN {}
}
--------------------------------------------------------------------------------

=== Does something with NoSuchMethod

--------------------------------------------------------------------------------
class JsonWithAccessors {
  Map<String, Object> _jsonData;
  JsonWithAccessors(String jsonString) {
    _jsonData = JSON.parse(jsonString);
  }

  noSuchMethod(Invocation invocation) {
    if (invocation.isAccessor) {
      var key = MirrorSystem.getName(invocation.memberName);
      key = key.replaceFirst('=', '');
      if (_jsonData.containsKey(key)) {
        if (invocation.isSetter) {
          _jsonData[key] = invocation.positionalArguments[0];
        } else {
          return _jsonData[key];
        }
      }
      return;
    }

    throw new NoSuchMethodError(this,
        _symbolToString(invocation.memberName),
        invocation.positionalArguments,
        _symbolMapToStringMap(invocation.namedArguments));
  }
}
--------------------------------------------------------------------------------

--------------------------------------------------------------------------------
String _symbolToString(Symbol symbol) => MirrorSystem.getName(symbol);

Map<String, dynamic> _symbolMapToStringMap(Map<Symbol, dynamic> map) {
  if (map == null) return null;
  var result = new Map<String, dynamic>();
  map.forEach((Symbol key, value) {
    result[_symbolToString(key)] = value;
  });
  return result;
}
--------------------------------------------------------------------------------


Usage:

--------------------------------------------------------------------------------
--------------------------------------------------------------------------------

=== Implementing getters and setters

--------------------------------------------------------------------------------
class Rectangle {
  num left;
  num top;
  num width;
  num height;

  Rectangle(this.left, this.top, this.width, this.height);

  // Define two calculated properties: right and bottom.
  num get right             => left + width;
      set right(num value)  => left = value - width;
  num get bottom            => top + height;
      set bottom(num value) => top = value - height;
}
--------------------------------------------------------------------------------

--------------------------------------------------------------------------------
main() {
  var rect = new Rectangle(3, 4, 20, 15);
  assert(rect.left == 3);
  rect.right = 12;
  assert(rect.left == -8);
}
--------------------------------------------------------------------------------


=== Overloading operators

--------------------------------------------------------------------------------
class Complex {
  double real, imag;

  Complex(this.real, this.imag);
  Complex operator+(Complex other) {
    return new Complex(this.real + other.real,this.imag + other.imag);
  }
}
--------------------------------------------------------------------------------

=== Making a class callable

--------------------------------------------------------------------------------
class Counter {
  int value = 0;

  Counter(this.value);

  call() {
    return value++;
  }
}
--------------------------------------------------------------------------------

=== Calling static members from a superclass


XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX


=== Using Libraries
Use import to specify how a namespace from one library is used in the scope of
another library.

For example, Dart web apps generally use the dart:html library, which they can
import like this:

import 'dart:html';


The only required argument to import is a URI[1] specifying the library. For
built-in libraries, the URI has the special dart: scheme. For other libraries,
you can use a file system path or the package: scheme. The package: scheme
specifies libraries provided by a package manager such as the pub tool. For
example:

import 'dart:io';
import 'package:mylib/mylib.dart';
import 'package:utils/utils.dart';
Specifying a library prefix

If you import two libraries that have conflicting identifiers, then you can
specify a prefix for one or both libraries. For example, if library1 and
library2 both have an Element class, then you might have code like this:

import 'package:lib1/lib1.dart';
import 'package:lib2/lib2.dart' as lib2;
// ...
var element1 = new Element();      // Uses Element from lib1.
var element2 = new lib2.Element(); // Uses Element from lib2.
Importing only part of a library

If you want to use only part of a library, you can selectively import the
library. For example:

import 'package:lib1/lib1.dart' show foo, bar; // Import only foo and bar.
import 'package:lib2/lib2.dart' hide foo;      // Import all names EXCEPT foo.

=== Implementing Libraries

Use library to name a library, and part to specify additional files in the
library.

Note
You donâ€™t have to use library in an app (a file that has a top-level main()
function), but doing so lets you implement the app in multiple files.

Declaring a library

Use library identifier to specify the name of the current library:

library ballgame;   // Declare that this is a library named ballgame.

import 'dart:html'; // This app uses the HTML library.
// ...Code goes here...


Associating a file with a library

To add an implementation file, put part fileUri in the file that has the library
statement, where fileUri is the path to the implementation file. Then in the
implementation file, put part of identifier, where identifier is the name of
the library. The following example uses part and part of to implement a library
in three files.

The first file, ballgame.dart, declares the ballgame library, imports other
libraries it needs, and specifies that ball.dart and util.dart are parts of
this library:

library ballgame;

import 'dart:html';
// ...Other imports go here...

part 'ball.dart';
part 'util.dart';

// ...Code might go here...
The second file, ball.dart, implements part of the ballgame library:

part of ballgame;

// ...Code goes here...
The third file, util.dart, implements the rest of the ballgame library:

part of ballgame;

// ...Code goes here...

=== Re-exporting libraries

You can combine or repackage libraries by re-exporting part or all of them.
For example, you might have a huge library that you implement as a set of
smaller libraries. Or you might create a library that provides a subset of
methods from another library.

// In french.dart:
library french;
hello() => print('Bonjour!');
goodbye() => print('Au Revoir!');

// In togo.dart:
library togo;
import 'french.dart';
export 'french.dart' show hello;

// In another .dart file:
import 'togo.dart';

void main() {
  hello();   //print bonjour
  goodbye(); //FAIL
}
XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX

