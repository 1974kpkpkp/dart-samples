== Functions, Classes, and Libraries

=== Using typedef to declare a function signature

==== Problem

You want to ensure that a function with a specific signature is used in your
application.

==== Solution

Use the `typedef` keyword to declare a custom function type. Then, specify the
use of that function type in your application.

==== Discussion

To create a typedef, prefix a function signature with the `typedef` keyword.
Here is an example:

--------------------------------------------------------------------------------
typedef void LogOutputFunc(String logData);
--------------------------------------------------------------------------------

The declaration above specifies that a function of the `LogOutputFunc` type
returns void and takes a single String argument.  With the custom type
definition in place, you can specify uses in your code for functions matching
the signature of `LogOutputFunc`.

Here is an example of class that uses a custom function type created using a
typedef:

--------------------------------------------------------------------------------
typedef void LogOutputFunc(String logData);

class Logger {
  LogOutputFunc func; // Must return void and take a single String argument.
  Logger(this.func);

  void log(String logData) {
    func(logData);
  }
}

// Method that matches the function type created using a typedef.
void timestampedPrint(String msg) => print('${new DateTime.now()}: $msg');

void main() {
  Logger l = new Logger(print);
  l.log('some log data');
  l.func = timestampedPrint;
  l.log('some log data');
}
--------------------------------------------------------------------------------

The Logger class accepts a function as a field, and that function must match
the signature of `LogOutputFunc`.  Two functions, the built in `print()`
function and the `timestampedPrint()` function match that signature (both
accept String a single String argument and both return void) and can be used
by the `Logger` class.

A `typedef` is always used as a  top-level library declaration. You cannot
specify a `typedef` within a class or a function.


=== Assigning default values to instance variables

==== Problem

You are implementing a class and want to assign default values to instance
variables of the class.

==== Solution

If you are not defining a constructor, assign default values when you declare
instance variables.  If you are defining a constructor, wrap default positional
parameters in `[]` and named parameters in `{}`.

==== Discussion

For simple classes where the default constructor provides sufficient
functionality, assign default values to instance variables when you declare
those variables:

--------------------------------------------------------------------------------
class Point {
  num x = 0;
  num y = 0;
}
--------------------------------------------------------------------------------

If you are defining a constructor, here is how you can assign default values to
positional parameters:

--------------------------------------------------------------------------------
class Point {
  num x, y;
  Point([this.x = 0, this.y = 0]);
}
--------------------------------------------------------------------------------

You can now call the constructor with zero, one, or two arguments:

--------------------------------------------------------------------------------
Point point = new Point();
point.x; // 0
point.y; // 0

point = new Point(3);
point.x; // 3
point.y; // 0

point = new Point(3, 4);
point.x; // 3
point.y; // 4
--------------------------------------------------------------------------------

And here is how you can assign default values to named parameters:

--------------------------------------------------------------------------------
class Point {
  num x, y;
  Point({this.x: 0, this.y: 0});
}
--------------------------------------------------------------------------------

When using named parameters, you can use `key:value` notation to pass in
arguments to the constructor:

--------------------------------------------------------------------------------
Point point = new Point();
point.x; // 0
point.y; // 0

point = new Point(x: 3);
point.x; // 3
point.y; // 0

point = new Point(x: 3, y: 4);
point.x; // 3
point.y; // 4
--------------------------------------------------------------------------------

Note: You may either use optional positional parameters or optinal named
parameters. You cannot use both in the same function or method. The following
code triggers an error:

--------------------------------------------------------------------------------
someFunctionThatWontWork(int x, [int y], {int z}) {
    // THIS DOES NOT WORK.
}
--------------------------------------------------------------------------------


=== Implementing named constructors

==== Problem

You want to define multiple constuctors for a class.

==== Solution

Use named constructors to implement different ways of instantiating a class.
Give these constructors names that make their purpose clear to users of your
class.

==== Discussion

Dart, unlike C++, C# or Java, and like most dynamically-typed languages, does
not support function, method or constructor overloading.  In the case of
functions and methods, it is easy enough to pick different names to get around
this restriction. But when working with constructors, the inability to overload
can be quite limiting. For this reason, Dart allows the use of named
constructors.

When defining a named constructor, prefix the name of the constructor with the
name of the class where it is defined. The example below shows a class with two
named constructors (along with a standard, unnamed constructor):

--------------------------------------------------------------------------------
class Point {
  num x, y;

  Point(this.x, this.y);

  // A named constructor.
  Point.zero(){
    x = 0;
    y = 0;
  }

  // Another named constructor.
  Point.fromJsonString(String jsonString) {
    var _json = parse(jsonString);
    x = _json['x'];
    y = _json['y'];
  }
}
--------------------------------------------------------------------------------

A named constructor is a useful way to make the intent of your code explicit.
By picking a descriptive constructor name, you can help clients of your code
quickly understand the reason you implemented the constructor.


=== Assigning value to final fields

=== Problem

You have a declared a field in a class final, and you want to assign a value
to it.

==== Solution

Use an initializer list to set the value of a final field.

==== Discussion

Final fields can only be assigned a value once, and after that, their value
cannot be changed. Since trying to assign a new value to a final field triggers
an error, using final protects variables from unintended changes.

A final field's value must be set before the constructor body executes. This
is done using an initializer list:

--------------------------------------------------------------------------------
class Book {
  final String ISBN;
  Book(String ISBN): ISBN = ISBN {}
}
--------------------------------------------------------------------------------

You can also use the following syntax:

--------------------------------------------------------------------------------
class Book {
  final String ISBN;
  Book(this.ISBN);
}
--------------------------------------------------------------------------------

Here is an example of a final field with a default value:

--------------------------------------------------------------------------------
class Tool {
  final String brand;
  Tool([brand = 'Makita']) : brand = brand;
}
--------------------------------------------------------------------------------

A class field in Dart can usually be accessed through an implicitly defined
getter and setter. Since a final field cannot be reassigned a new value, no
implicit setter is created for it:

--------------------------------------------------------------------------------
void main() {
  var book = new Book('978-1449330897');
  book.ISBN = '...'; // ERROR, no setter available.
}
--------------------------------------------------------------------------------

Making a field final only means that it cannot be assigned to a new object. If
the object assigned to the final field is mutable, that object can still be
modified. Here is an example of a final variable that is assigned to a mutable
object:

--------------------------------------------------------------------------------
class Person {
  String name;
  int age;
  final Address address;
  Person(this.name, this.age, this.address);
}

class Address {
  String city, state;
  Address(this.city, this.state);
}

void main() {
  Person person = new Person('Rohan', 13, new Address('Boston', 'MA'));
  person.address.city = 'Berkeley'; // OK to change this.
  person.address = new Address('New York', 'NY'); // Not OK. ERROR.
}
--------------------------------------------------------------------------------

In the example above, `address` is marked `final`, so it must always
point to the object it was initially assigned to.  However, an Address object
itself is mutable, and the values of its fields can be modified without
triggering an error. Trying to assign `address` to a different Address object,
however, is prohibited because `address` has been declared `final`.


=== Implementing a const constructor

==== Problem

You want to define a constructor that generates a compile-time constant.

==== Solution

Dart allows you to make a constructor const, but places the following
restrictions:

* A const constructor cannot have a body.
* All the fields of the class must be declared final. This means that they
get assigned values once, and cannot be changed after that.
* The constructor initializer list must contain only compile-time constants as
values.
* A const constructor must be explicitly prefixed with the `const` keyword.

Here is an example of a class that implements a couple of const constructors:

--------------------------------------------------------------------------------
class Point {
  final int x;
  final int y;
  const Point(this.x, this.y);
  const Point.zero(): x = 0, y = 0;

  // Non-const: initializer list contains non-constants.
  Point.fromOther(Point other): x = other.x, y = other.y;
}
--------------------------------------------------------------------------------

Code that creates a compile-time constant uses `const` instead of `new` in the
constructor invocation:

--------------------------------------------------------------------------------
const Point point0 = const Point.zero();
const Point point1 = const Point(0, 0);
point0 == point1;          // true
identical(point0, point1); // true
--------------------------------------------------------------------------------

Using `new` instead of `const` is not illegal, and it will create an object,
but that object is not a compile-time constant:

--------------------------------------------------------------------------------
Point point3 = new Point.zero(); // Not const.
Point point4 = new Point(0, 0);  // Not const.
identical(point3, point4);       // false
--------------------------------------------------------------------------------


=== Specifying a default implementation for an abstract class

==== Problem

You have defined an abstract class that you want others to implement, but
you'd also like to provide a default implementation of the class.

==== Solution

Use a factory constructor to give your abstract class a default implementation.

==== Discussion

In Dart, all classes define an implicit interface. You can use the interface
defined by a class by implementing that class. This is done using the
`implements` keyword.  Sometimes, you expect one particular implementation of
an abstract class to be commonly used, and it makes sense to provide that
implementation as a default. This is commonly done in Dart through the use of
factory constructors.

You can define a factory constructor using the `factory` keyword. Here is an
example of an abstract class which implements a factory constructor and provides
a default implementation:

--------------------------------------------------------------------------------
abstract class Book {
  ...

  factory Book() {
    return new _Book();
  }
}

// Default implementation.
class _Book implements Book {
  ...
}
--------------------------------------------------------------------------------

While you cannot instantiate an abstract class, using a factory constructor
makes your abstract class _appear_ instantiable. In the code below, you are
creating a _Book, but that implementation detail is hidden from the user:

--------------------------------------------------------------------------------
var book = new Book();
book.runtimeType.toString(); // '_Book'
book is Book;                // true
book is _Book;               // true
--------------------------------------------------------------------------------

Defining factory constructors to provide default implemetation for abstract
classes is a familiar pattern in Dart. For example, when you call the
`new List()` or `new String.fromCharCode()` factory constructors, you are using
default implementation provided by the List and String abstract classes.  The
File class, found in the dart:io library, is another example of an abstract
class that provides a default implementation:

--------------------------------------------------------------------------------
abstract class File implements FileSystemEntity {
  /**
   * Create a File object.
   */
  factory File(String path) => new _File(path);

  ...
}
--------------------------------------------------------------------------------

The implementation, partially reproduced below, provides the constructor that
creates an  instance when the File factory constructor is invoked:

--------------------------------------------------------------------------------
class _File implements File {
  final String path;
  SendPort _fileService;

  // Constructor for file.
  _File(String this.path) {
    if (path is! String) {
      throw new ArgumentError('${Error.safeToString(path)} '
                              'is not a String');
    }
  }
  ...
}
--------------------------------------------------------------------------------


=== Implementing caching using a factory constructor

==== Problem

You want to implement a constructor that returns a new object only if it is not
present in a cache.

==== Solution

Use a factory constuctor that examines the contents of a cache for an object
matching a description. If the matching object is found, have the constructor
return that object. If it isn't found, have the constructor create and return
a new object.

==== Discussion

It is often desirable to cache objects in applications, and create new objects
only when necessary. Factory constructors provide a handy mechanism for
producing instances that are not newly allocated, but come from a cache.

Here is an example of class that implements a caching factory constructor:

--------------------------------------------------------------------------------
class GamePiece {
  final String pieceName;
  static Map<String, GamePiece> _cache = {};
  GamePiece._create(this.pieceName);

  factory GamePiece(String pieceName) {
    GamePiece piece = _cache[pieceName];
    if (piece == null) {
      piece = new GamePiece._create(pieceName);
      _cache[pieceName] = piece;
    }
    return piece;
  }
}
--------------------------------------------------------------------------------

The class defines a static variable, `_cache` to store existing objects.  It
defines a factory constructor that takes the name of a game piece as a an
argument.  When this constructor is invoked, the constructor first checks the
cache for a matching piece. If it is found, the constructor returns that piece,
and if it isn't, the constructor creates a new object, adds it to the cache and
returns it.

Calling this factory constructor with the same string argument returns the same
object:

--------------------------------------------------------------------------------
var piece1 = new GamePiece('monster');
var piece2 = new GamePiece('monster');
identical(piece1, piece2); // true
--------------------------------------------------------------------------------

When a piece is created with a new game piece name, a new object is created
and returned:

--------------------------------------------------------------------------------
piece3 = new GamePiece('angel');
identical(piece1, piece3);  // false
--------------------------------------------------------------------------------


=== Implementing a redirecting constructor

==== Problem

So that you don't have to implement multiple constructors with overlapping
logic, you want some of your constructors to delegate their work to other
constructors.

==== Solution

Use redirecting constructors. Such constructors exist for the sole purpose of
invoking other constructors.

==== Discussion

A redirecting constructor does not have a body; instead, it has a redirect
clause that specifies the constructor it is redirecting to and the arguments
that it is passing to that constructor.

Here is an example of a class that implements a standard, non-redirecting
constructor, and then implements a redirecting constructor that delegates to the
standard constructor:

--------------------------------------------------------------------------------
class Rectangle {
  static const int DEFAULT_SIZE = 4;
  num length, width;

  Rectangle(this.length, this.width);

  // Redirecting constructor.
  Rectangle.square(num side): this(side, side);

  String toString() => '${this.length}, ${this.width}';
}
--------------------------------------------------------------------------------

Invoking `new Rectangle.square()` permits a client of the class to create a
(square) Rectangle by passing in only the single required dimension. The extra
functionality provided by this redirecting constructor does not require any
duplicated implementation logic between the two constructors.

When using a generative redirecting constructor, you may only redirect to
constructors of the same class (note the use of `this` in the example):

--------------------------------------------------------------------------------
Rectangle.square(num side): this(side, side);
--------------------------------------------------------------------------------

You can redirect to a constructor in a different class through the use of
redirecting factory constructor. Here is an example of such a constructor from
the Symbol class defined in the dart:core library:

--------------------------------------------------------------------------------
class Symbol {
  const factory Symbol(String name) = _collection_dev.Symbol;
}
--------------------------------------------------------------------------------

Unlike the generative redirecting constructor example, note that you don't
specify the arguments that are passed to the target constructor.  Calling a
redirecting factory constructor causes the target constructor to be called with
the actual arguments passed to the redirecting constructor.


=== Replacing a class field with a getter and a setter

==== Problem

You API has evolved and there's no reason to use a field from the original API.
Yet, you don't want to break backwards compatibility. What should you do?

==== Solution

Replace the original field with a getter and setter that plugs into the new
API.

==== Discussion

Consider a simple Game class with an `isBoardLoaded` boolean field:

--------------------------------------------------------------------------------
class Game {
  bool isBoardLoaded = false;
}
--------------------------------------------------------------------------------

You used this class to create Game objects, and you checked the game board's
status using the `isBoardLoaded` field.

Over time, the Game API evolved, and you decided to create a Board field in
the Game class. You defined a Board class and implemented an `isLoaded` boolean
field to keep track of the board status:

--------------------------------------------------------------------------------
class Game {
  bool isBoardLoaded = false; // No longer needed, but still present.
  Board board;
}

class Board {
  bool isLoaded = false;     // Board has an isLoaded field now.
  // ...
}
--------------------------------------------------------------------------------

You now have two ways of checking the board status:

--------------------------------------------------------------------------------
game.isBoardLoaded;
game.board.isLoaded;
--------------------------------------------------------------------------------

You would like to remove the `isBoardLoaded` field from the Game class, but
are afraid that this would break the code of `Game`'s clients.

Defining a getter and a setter for `isBoardLoaded` allows your API to
continue supporting that field:


--------------------------------------------------------------------------------
class Game {
  Board board;

  bool get isBoardLoaded => board.isLoaded;

  void set isBoardLoaded(bool isLoaded) {
    board.isLoaded = isLoaded;
  }
}
--------------------------------------------------------------------------------

Clients of your class are not exposed to implementation changes, and are
unaware that calling `isBoardLoaded` simply accesses the `isLoaded` property
of `board`. They can continue to use your class as before:

--------------------------------------------------------------------------------
var game = new Game();
game.board = new Board();
game.isBoardLoaded; // Calls board.isLoaded.
--------------------------------------------------------------------------------

Using getters and setters in this manner allows you to start with something
simple, and lets you evolve your API over time without breaking existing code.


=== Invoking a superclass constructor

==== Problem

Inheritance provides a child class the methods and fields of its superclass.
But constructors do not inherit. How can you use a superclass constructor from
the child class?

==== Solution

You must define a constructor in the child class and explicitly invoke the
superclass constructor using the `super` keyword.

==== Disucssion

The call to `super` must be placed within a constructor's initializer block,
right after the constructor's parameter list and before the constructor body.

Here is an example of the use of `super`:

--------------------------------------------------------------------------------
class Person {
  String name;
  Person(this.name);
}

class Employee extends Person {
  String employeeID;

  Employee(name, employeeID): super(name) {
    this.employeeID = employeeID;
  }
}
--------------------------------------------------------------------------------

In this code, `Person` contains a single field, `name`, and `Employee` extends
`Person` and introduces an additional field, `employeeID`. The call to `super`
sets the value of `name`. After that, the value of `employeeID` is set within
the constructor body.

While the call to `super` can only be placed within the constructor initializer
list, the value of `employeeID` may be set within the body of the constructor or
in the constructor initializer list:

--------------------------------------------------------------------------------
Employee(name, employeeID) : super(name), employeeID = employeeID {}
--------------------------------------------------------------------------------

This can also be written using an initializing formal:

--------------------------------------------------------------------------------
Employee(name, this.employeeID) : super(name) {}
--------------------------------------------------------------------------------

If the superclass defines a named constructor, you can use `super` to invoke
that constructor from the child class:

--------------------------------------------------------------------------------
class Item {
  String name;
  Item();
  Item.named(this.name);  // Named constructor in the superclass.
}

class Widget extends Item {
  String sku;
  Widget(name, this.sku): super.named(name);
}
--------------------------------------------------------------------------------


=== Calling static members defined in a superclass

==== Problem

You want to invoke a static member that was defined in a superclass.

==== Solution

When invoking the static member, prefix it with the name of the class where it
was defined.

==== Discussion

Here is an example of a static method defined in a superclass being invoked
in a child class:

--------------------------------------------------------------------------------
abstract class Parent {
  static int theAnswer() => 42;
}

class Child extends Parent {
  String getTheAnswer() => "The answer is: ${Parent.theAnswer()}";
}

void main() {
  print(new Child().getTheAnswer()); // 42
}
--------------------------------------------------------------------------------

Since static members do not inherit in Dart, you canot use `super` to invoke a
static member defined in the superclass. The following code, where
`Parent.getAnswer()` is changed to `super.getAnswer()`, generates a
`NoSuchMethodError`:

--------------------------------------------------------------------------------
// DON'T DO THIS.
class Child extends Parent {
  String getTheAnswer() => "The answer is: ${super.theAnswer()}";
}
--------------------------------------------------------------------------------

Using `super.theAnswer()` looks for an _instance_ method named `theAnswer()`
defined in `Parent` or its inheritance heirarchy. Since no such method exists,
a `NoSuchMethodError` is triggered.


=== Handling calls to NoSuchMethod

==== Problem

You want to implement a custom response when an member not defined in a class
is invoked on an instance of that class.

==== Solution

Implement a custom version of the `noSuchMethod()` method in your class. Query
the Invocation object provided to `noSuchMethod()` and devise a custom response
based on the member invoked and the arguments passed.

==== Discussion

When you invoke a member that is not defined in a class, Dart looks for that
member in the inheritance hierarchy of that class.  If no class in the
inheritance hierarchy implements the member, Dart looks for a `noSuchMethod()`
method that defines behavior that should occur if an invoked member is not
found. If `noSuchMethod()` is not defined within a class or any of its parent
classes, Dart invokes the default `noSuchMethod()` provided by the Object class,
which throws a `NoSuchMethodError`.

Implementing a custom `noSuchMethod()` gives you flexibility in how you handle
method invocations that are not defined in a class.  Here is the
`noSuchMethod()` syntax:

--------------------------------------------------------------------------------
class MyClass {
  ...

  noSuchMethod(Invocation invocation) {
   // Get information about the invocation and execute some code.
  }
}
--------------------------------------------------------------------------------

When `noSuchMethod()` is invoked, an `Invocation` object is passed to it. You
can query that `Invocation` object to get the name of the invoked member, find
out whether it was a method, getter or setter, and get the list of arguments
passed to it. Then, you can choose to either run some aribitrary code and return
a value, or you can explicitly raise a `NoSuchMethodError` yourself. If you
return a value, that value becomes the result of the original invocation.

The example below is inspired by the creative use of `noSuchMethod()` in Chris
Buckett's JsonObject Pub package (http://pub.dartlang.org/packages/json_object)
to implement dot notation access for properties of a JSON object.

When you parse JSON strings using the `dart:json` library, you get a map of
name/value pairs. You can access properties of the JSON object using the
obj[name] notation:

--------------------------------------------------------------------------------
import 'dart:json';

void main() {
  var jsonPerson = '{"name": "joe", "date": [2013, 3, 10]}';
  var person = parse(jsonPerson);
  print(person['name']);  // 'joe'
  print(person['date']);  // [2013, 3, 10]
}
--------------------------------------------------------------------------------

But you cannot do so using dot notation:

--------------------------------------------------------------------------------
// THIS DOES NOT WORK.
person.name;          // No 'name' getter defined
person.name = 'mark'; // No 'name' setter defined
--------------------------------------------------------------------------------

This is because the `person` object has no `name` getter or setter, and the code
above triggers a call to `noSuchMethod()`, which results in a
`NoSuchMethodError`.

The approach that the JsonObject package takes, and that we demonstrate here,
is to implement the missing getters and a setters through a wrapper class that
defines a `noSuchMethod()`. When an invocation triggers a call to
`noSuchMethod(), we get its name. Then, we access the associated property
within the JSON map:

--------------------------------------------------------------------------------
class JsonWithAccessors {
  Map<String, Object> _jsonData;

  JsonWithAccessors(String jsonString) {
    _jsonData = JSON.parse(jsonString);
  }

  noSuchMethod(Invocation invocation) {
    if (invocation.isAccessor) {
      var key = MirrorSystem.getName(invocation.memberName);
      key = key.replaceFirst('=', '');

      if (_jsonData.containsKey(key)) {
        if (invocation.isSetter) {
          _jsonData[key] = invocation.positionalArguments[0];
        } else {
          return _jsonData[key];
        }
      }
      return;
    }

    throw new NoSuchMethodError(this,
        _symbolToString(invocation.memberName),
        invocation.positionalArguments,
        _symbolMapToStringMap(invocation.namedArguments));
  }
}

// Convenience functions for converting symbols to strings.
String _symbolToString(Symbol symbol) => MirrorSystem.getName(symbol);

Map<String, dynamic> _symbolMapToStringMap(Map<Symbol, dynamic> map) {
  if (map == null) return null;
  var result = new Map<String, dynamic>();
  map.forEach((Symbol key, value) {
    result[_symbolToString(key)] = value;
  });
  return result;
}
--------------------------------------------------------------------------------

In our implementation of `noSuchMethod()`, we use the Invocation object's
`isAccessor` property to check if the invoked member is an accessor, and we
use the `memberName` property to get the invoked member's name.  If the
accessor is a setter, we update its values in the JSON map, and if it is a
getter, we get its value from the JSON map.

If the invocation is an accessor, but does not represent a key in the JSON
map, we return a null value. And if the invocation is not an accessor, we throw
a `NoSuchMethodError`, passing to it the name of the member invoked, and its
positional and named arguments.

You can use the class defined above in this manner:

--------------------------------------------------------------------------------
var jsonPerson = '{"name": "joe", "date": [2013, 3, 10]}';
var person = new JsonWithAccessors(jsonPerson);
person.name;          // 'joe'
person.name = 'mark';
person.name;          // 'mark'
person.height;        // null
person.name();        // throws NoSuchMethodError

--------------------------------------------------------------------------------

When defining a `noSuchMethod()`, it is important to clearly define the cases
that trigger some arbitrary code, and then explicity throw a `NoSuchMethodError`
for all other cases. This ensures that only invocations you want to explicitly
handle get special treatment, and all other undefined members continue to
generate the expected `NoSuchMethodError`.


=== Checking the type of an object at runtime

==== Problem

You want to check the type of an object at runtime.

==== Solution

Use the `is`, `is!`, and `as` operators for checking types at runtime.

--------------------------------------------------------------------------------
var list = new List();
list is List; // true
--------------------------------------------------------------------------------

==== Discussion

The `is` and `is!` operators go beyond just checking if an object's
runtimeType matches a type. Using `is` returns true if the object
implements an interface specified by the type. So, since Lists implement the
Iterable interface, `list` is also an Iterable:

--------------------------------------------------------------------------------
list is Iterable; // true
--------------------------------------------------------------------------------

Both `is` and `is!` work with superclasses as well:

--------------------------------------------------------------------------------
class Animal {}
class Dog extends Animal {}

new Dog() is Animal; // true
new Dog() is Object; // true. Animal implicitly extends Object.
--------------------------------------------------------------------------------

It is a common pattern to test the type of an object, and then use an
expresson involving that object:

--------------------------------------------------------------------------------
if (obj is Book) {
  obj.available = false;
}
--------------------------------------------------------------------------------

You can make the code shorter using the `as` operator:

--------------------------------------------------------------------------------
(obj as Book).available = false;
--------------------------------------------------------------------------------


=== Comparing Dart objects for equality

==== Problem

You want find out if two objects are equal.

==== Solution

For testing object equivalence, use the `==` and `!=` operators. For testing
object identity, use  the `identical()` function.

=== Discussion

Most of the time, you just want to find out if two objects are equal. Use the
`==` and `!=` operators for this:

--------------------------------------------------------------------------------
'hello'.toUpperCase() == 'HELLO'; // true
--------------------------------------------------------------------------------

For the rare times when you need to test object identity, use the
`identical()` function. This function returns true only if the two variables
point to the same object in memory:

--------------------------------------------------------------------------------
const List<int> list1 = const [1, 2, 3];
const List<int> list2 = const [1, 2, 3];

list1 ==  list2;         // true
identical(list1, list2); // true
--------------------------------------------------------------------------------

Both `list1` and `list2` are const, and they point to the same object in
memory.  The two lists are identical.

You can implement `==` for your own types. Here is an example of a class that
defines the `==` operator to test if an instance of the class is equal to
another instance of the same class:

--------------------------------------------------------------------------------
class Employee {
  String name, employeeID;

  Employee(this.employeeID, this.name);

  bool operator ==(Employee other) {
    if (identical(other, this)) return true;
    return (other.employeeID == employeeID);
  }

  int get hashCode {
    int result = 17;
    result = 37 * result + employeeID.hashCode;
    return result;
  }
}

void main() {
  var mike = new Employee('019583', 'Mike');
  var michael = new Employee('019583', 'Michael');

  mike == michael;          // true
  identical(mike, michael); // false
}
--------------------------------------------------------------------------------

In the example above, two Employee objects are considered to be equal if they
have the same employee ID.

You don't have to implememnt `!=`, since Dart infers that from your definition
of `==`:

--------------------------------------------------------------------------------
mike != michael; // false
--------------------------------------------------------------------------------

If you override the `==` operator, you must also override the `hasCode` getter
(as we have done in our example). This is because if two objects are equal
using `==`, then calling the `hashCode` getter for those objects should return
the same integer value:

--------------------------------------------------------------------------------
mike.hashCode == michael.hashCode; // true
--------------------------------------------------------------------------------

If you do not override `hashCode` when overriding `==` (or vice verse), two
distinct instances of your class may well evaluate as equal, but they will end
up with distinct hash values. If you then, say, wanted to insert a `Person`
instance into a hash, you may be stuck dealing with inconsistent hash values
and may not be able to retreive that object from the hash.  Always override the
`hashCode` property if you override `==`.


=== Overloading the [] operator

==== Problem

You use the `[]` and `[]=` operators to access members of lists and maps. You
would like to overload these operators in your class to allow index access to
members of your class.

==== Solution

Overloading the `[]` and `[]=` operators using the `operator` keyword and
map index values to members of your class.

==== Discussion

Here is an example of a class that overloads the `[]` and `[]=` operators to
allow convenient access to a member field:

--------------------------------------------------------------------------------
class Vector3D {
  final Float32List _storage = new Float32List(3);

  Vector3D(double x_, double y_, double z_) {
    _storage[0] = x_;
    _storage[1] = y_;
    _storage[2] = z_;
  }

  double operator[](int i) => _storage[i];
  void operator[]=(int i, double v) { _storage[i] = v; }
}
--------------------------------------------------------------------------------

The Vector3D class provides functionality for a 3d vector. The three double
parameters that define the vector are stored in a private container, `_storage`.
Overloadin the `[]` and `[]=` operators lets you access members of `_storage`
using an index:

--------------------------------------------------------------------------------
var v3 = new Vector3D(3.1, 2.7, 4.5);
doSomethingWith(v3[0]); // Using []
v3[0] = 4.2;            // Using []=
--------------------------------------------------------------------------------

This type of overloading represents a common pattern in Dart and examples of
this behavior are commonplace. The example used in this recipe is based on the
Vector3 class implemented in the
http://pub.dartlang.org/packages/vector_math[vector_math pub package]


=== Making a class instance callable

==== Problem

You want to make an instance of a class callable. Maybe you've defined a class
that wraps a single method, and instead of calling that method on a
class instance, you'd prefer users of the class to invoke the class instance
directly.

==== Solution

Define a `call()` method in the class. Doing this allows an instance of that
class to be invoked as if it were a function.

==== Discussion

Here is an example of a simple Counter class that defines the `call()` method
that increments the value of an instance variable:

--------------------------------------------------------------------------------
class Counter {
  int value;
  Counter([this.value = 0]);
  call() => value++;
}

void main() {
  var c = new Counter(10);
  print(c());  // 10
  print(c());  // 11

}
--------------------------------------------------------------------------------

If you invoke a class instance as a function, but neglect to define `call()`,
`noSuchMethod()` is called.

--------------------------------------------------------------------------------
class Point {
  double x, y;
  Point(this.x, this.y);
}

void main() {
  new Point(3.0, 4.0)();
}
--------------------------------------------------------------------------------

Running the code above generates the following error message:

--------------------------------------------------------------------------------
Unhandled exception:
Class 'Point' has no instance method 'call'.

NoSuchMethodError : method not found: 'call'
Receiver: Instance of 'Point'
Arguments: []
--------------------------------------------------------------------------------


=== Importing libraries

==== Problem

You want to use the contents of a library in your code.

==== Solution

Use `import` to bring the contents of a library into your code. For example,
you can import the `dart:json` library in your code like this:

--------------------------------------------------------------------------------
import 'dart:json';
--------------------------------------------------------------------------------

==== Discussion

Importing a library in this manner gives you access to the namespace of
the imported library. You can use members of the imported library as if
they had been defined in the current scope:

--------------------------------------------------------------------------------
void main() {
  var jsonString = stringify(string);
  parse(jsonString);
}
--------------------------------------------------------------------------------

Built-in Dart libraries are imported using the `dart:` syntax. To import
libraries from a package manager such as Pub, use the `package:` import syntax:

--------------------------------------------------------------------------------
import 'package:unittest/unittest.dart';
--------------------------------------------------------------------------------

You can specify a prefix when you import a library:

--------------------------------------------------------------------------------
import 'dart:json' as json;

void main() {
  var jsonString = json.stringify(string);
  json.parse(jsonString);
}
--------------------------------------------------------------------------------

Specifying a prefix not only clarifies the origins of an imported identifier
in your code, it helps prevent name collisions if two libraries have
conflicting identifiers.

For example, if library1 and library2 both define a top level `parse()`
function, then you might structure your imports like this:

--------------------------------------------------------------------------------
import 'package:library1/library1.dart' as library1;
import 'package:library2/library2.dart' as library2;

library1.parse();
library2.parse();
--------------------------------------------------------------------------------

You can selectively import the contents of a library. For example, the following
import declaration imports only the `parse()` and `invoke()` functions from a
library:

--------------------------------------------------------------------------------
import 'package:library1/library1.dart' show parse, invoke;
--------------------------------------------------------------------------------

This declaration imports everything _except_ the `parse()` function:

--------------------------------------------------------------------------------
import 'package:library1/library1.dart' hide parse;
--------------------------------------------------------------------------------


=== Declaring a library

==== Problem

You want the code you are writing to be reusable in other parts of your
application, or you want to share code with multiple apps.

==== Solution

Use a `library` declaration at the top of a file to name a library, and use a
`part of` declaration to distribute the library over several files.

==== Discussion

Most libraries in Dart are implemented in multiple files. The unittest library,
for example, is defined in the `unittest.dart` file with the following
declaration:

--------------------------------------------------------------------------------
library unittest;
--------------------------------------------------------------------------------

That file also contains these two `part` declarations:

--------------------------------------------------------------------------------
part 'src/config.dart';
part 'src/test_case.dart';
--------------------------------------------------------------------------------

These declarations specify that the library name is unittest, and that parts of
the library are distributed in two files located in the src directory.

The `test_case.dart` and `config.dart` files in turn contain the following
declaration, which specifies that they are part of the unittest library:

--------------------------------------------------------------------------------
part of unittest;
--------------------------------------------------------------------------------


=== Re-exporting libraries

==== Problem

You have imported libraries in your library, and you would like to make all or
part of the imported libraries to be made available to clients of your library.

==== Solution

Re-export part or all of any libraries that you have imported using the
`export` keyword.

==== Discussion

Assume that a `parser` library exists that has a couple of top-level
functions:

--------------------------------------------------------------------------------
// In parser.dart:
library parser;
parse()    => ...;
tokenize() => ...;
--------------------------------------------------------------------------------

You can import `parser` in your own library using the `import` keyword. This
allows you to use the `parse()` and `tokenize()` functions defined in `parser`.
You can then choose to make one or both of those functions available to clients
of your library. Here is what the `import` and `export` syntax looks like:

--------------------------------------------------------------------------------
// In some my_lib.dart file
library myLib;
import 'parser.dart';
export 'parser.dart' show parse;
--------------------------------------------------------------------------------

Anyone who imports `myLib` can now use the `parse()` function, which your library
imported from the `parser` library, and then re-exported:

--------------------------------------------------------------------------------
// In your_lib.dart file:
import 'my_lib.dart';

void main() {
  parse();
}
--------------------------------------------------------------------------------

Since `myLib` exported `parse()` but not `tokenize()`, invoking `tokenize()`
generates an error:

--------------------------------------------------------------------------------
void main() {
  parse();    // OK.
  tonenize(); // NoSuchMethodError
}
--------------------------------------------------------------------------------

